/*
 * Created by Katie Strauss
 * April 2019
 * Pseudocode template generated by Mari Good
 */

import './general.js';

// Create a class called MidnightSky

class MidnightSky {
    
    constructor() {
        /*
        - Part 1 - Create and draw stationary stars
            - Initialize instance variables for all of the ui elements in the constructor
                -   this.$canvas = 
                -   this.$context = 
                -   this.animateInterval; 
        */

        this.$canvas = document.querySelector('canvas');
        this.$context = this.$canvas.getContext('2d');
        

        /*
        - Initilize some other instance variables that are data related in the constructor
        */
        this.defaults = {
            star: {
                color: 'rgba(255, 255, 255, .5)',
                width: 3,
                randomWidth: true
            },
            line: {
                color: 'rgba(255, 255, 255, .5)',
                width: 0.2
            },
            position: {
                x: 0,
                y: 0
            },
            width: window.innerWidth,
            height: window.innerHeight,
            velocity: 0.1,
            length: (window.innerWidth * window.innerWidth) / 10000,
            distance: 100,
            radius: 150,
            stars: []
        };
        this.config = JSON.parse(JSON.stringify(this.defaults));

        this.createStar = this.createStar.bind(this);
        this.drawStar = this.drawStar.bind(this);
        this.starSize = this.starSize.bind(this);
        this.colorStar = this.colorStar.bind(this);
        this.starStart = this.starStart.bind(this);
        this.explosionSize = this.explosionSize.bind(this);
        this.setVelocity = this.setVelocity.bind(this);
        this.moveStar = this.moveStar.bind(this);
        this.moveStars = this.moveStars.bind(this);
        this.animateStars = this.animateStars.bind(this);
        this.highlight = this.highlight.bind(this);

        this.setCanvas();
        this.setContext();
        this.setInitialPosition();
        this.createStars();
        this.drawStars();

        this.animateInterval = setInterval(this.animateStars, 16);

        this.$canvas.addEventListener('mousemove', (e) => { this.highlight(e); this.drawLines(); });
        window.addEventListener('resize', () => {
            clearInterval(this.animateInterval);
            this.config.width = window.innerWidth;
            this.config.height = window.innerHeight;
            this.setCanvas();
            this.setContext();
            this.setInitialPosition();
            this.setLength();
            this.createStars();
            this.drawStars();
            this.animateInterval = setInterval(this.animateStars, 16);
        });
    }

    setLength() {
        this.config.length = Math.ceil((window.innerWidth * window.innerHeight) / 10000);
        console.log("array length is " + this.config.length);
    }

    /*
        - Write the method setCanvas
            -   set the width and the height of the canvas to the 
                width and the height in the config object
            -   bind the class to the method in the constructor
            -   call the method in the constructor
    */

    setCanvas() {
        let canvasHeight = this.config.height;
        let canvasWidth = this.config.width;
        this.$canvas.height = canvasHeight;
        this.$canvas.width = canvasWidth;
        console.log("height = " + canvasHeight + " and width = " + canvasWidth);
    }

    /*
        - Write the method setContext
            -   set the strokeStyle, fileStyle and lineWidth properties of the context
                based on corresponding values in the config object
            -   bind the class to the method in the constructor
            -   call the method in the constructor
    */

    setContext() {
        this.$context.lineWidth = this.config.lineWidth;
        this.$context.strokeStyle = this.config.strokeStyle;
        this.$context.fillStyle = this.config.fillStyle;
    }

    /*
        - Write the method setInitialPosition
            -   set the x and y position in the config object to 
                half of the canvas width and height respectively
            -   bind the class to the method in the constructor
            -   call the method in the constructor
    */

    setInitialPosition() {
        this.config.position.x = this.$canvas.width / 2;
        this.config.position.y = this.$canvas.height / 2;
    }

    /*
        - Write the method createStar
            -   make a copy of the default star characteristics
            -   add x to the star - random number relative to the canvas width
            -   add y to the star - random number relative to the canvas height
            -   add vx to the star - random velocity in the x direction
            -   add vy to the star - random velocity in the y direction
            -   add radius to the star - random size
            -   return the star
            -   bind the class to the method in the constructor
    */

    createStar(i) {

        let newStar = {
            color: this.colorStar(),
            position: this.starStart(),
            velocity: this.setVelocity(),
            radius: this.starSize(),
            maxRadius: 0,
            index: i,
            lines: true,
        };

        newStar.maxRadius = this.explosionSize(newStar.radius);

        // make sure x is in bounds
        if ((newStar.position.x - newStar.radius) <= 0)
            newStar.position.x += newStar.radius;
        else if ((newStar.position.x + newStar.radius) >= this.config.width)
            newStar.position.x -= newStar.radius;

        // make sure y is in bounds
        if ((newStar.position.y - newStar.maxRadius) <= 0)
            newStar.position.y += newStar.maxRadius;
        else if ((newStar.position.y + newStar.maxRadius) >= this.config.height)
            newStar.position.y -= newStar.maxRadius;

        return newStar;
    }

    // starting position for a new star
    starStart() {
        let position = {
            x: (Math.random() * this.$canvas.width),
            y: (Math.random() * this.$canvas.height),
        };

        return position;
    }


    /*
     * starSize takes no parameters 
     * starSize uses a random number and a weighted conditional control
     * structure to adjustthe probabilities of getting a given size star
     */

    starSize() {
        let randSize = Math.floor(Math.random() * 215);
        
        if (randSize < 10) {                //  4.65%
            return .1;
        } else if (randSize < 20) {         //  4.65%
            return .2;
        } else if (randSize < 40) {         //  9.30%
            return .3;
        } else if (randSize < 70) {         // 13.95%
            return .4;
        } else if (randSize < 110) {        // 13.95%
            return .5;
        }else if (randSize < 160) {         // 23.26%
            return .6;
        } else if (randSize < 180) {        //  9.30%
            return .7;
        } else if (randSize < 190) {        //  4.65%
            return .8;
        } else if (randSize < 200) {        //  4.65%
            return .9;
        } else if (randSize < 205) {        //  2.33%
            return 1;
        } else if (randSize < 208) {        //  1.39%
            return 1.25;
        } else if (randSize < 211) {        //  1.39%
            return 1.5;
        } else if (randSize < 213) {        //  0.93%
            return 2;
        } else if (randSize < 214) {        //  0.47%
            return 2.5;
        } else {                            //  0.47%
            return 3;
        }                                   // percentages are rounded and may not equal 100% if added together
    }

    explosionSize(radius) {
        let explosion = (radius + 1) * Math.floor(Math.random() * 5 + 2);
        return explosion;
    }

    /*
     * Stars are more fun when they're not all the same color.
     * colorStar accepts no parameters
     * colorStar returns a hex value from an array of possible colors
     * based on a quick google search for rgb values for the colors of stars
     * in an attempt to maintain a modicum of realism source:
     * http://www.vendian.org/mncharity/dir3/starcolor/
     */

    colorStar() {
        let starColors = [
            '#b5c7ff',      // (A1V)    - Sirius
            '#fff5f2',      // (G2V)    - Sun
            '#ffca8a',      // (M1I)    - Betelgeuse
            '#b6ceff',      // (B8I)    - Rigel
            '#ffdfb5',      // (K1III)  - Arcturus
            '#ffeedd',      // (K0V)    - Alpha Centauri B
            '#f1efff',      // (F5IV-V) - Procyon
            '#ffbb7b',      // (M6V)
            '#9db4ff',      // (O5V)
            'rgba(255, 255, 255, .5)'   // default
        ];
        return starColors[Math.floor(Math.random() * starColors.length)];
    }

    /* 
     * setVelocity accepts no parameters
     * setVelocity returns a 2 element array indicating both x and y velocity
     */

    setVelocity() {
        // determine negative or positive axial drifts
        let negPos = {
            x: (Math.floor(Math.random() * 10204) % 2),  // larger numbers typically produce more effective pseudorandom results
            y: (Math.floor(Math.random() * 10309) % 2)   // then mod 2 to get a value of 1 or 0 for simple binary control
        };

        // set numbers for x and y velocity
        // results can be anywhere from .1 to 1
        let velocity = {
            x: (Math.floor(Math.random() * 100 + 21)/ 100),
            y: (Math.floor(Math.random() * 100 + 21) / 100)
        };

        // potential for x or y to have negative velocity
        // which should translate to leftward or downward motion
        if (negPos.x == 1) {
            velocity.x *= -1;
        }
        if (negPos.y == 0) {
            velocity.y *= -1;
        }

        return velocity;
    }

    /*
      - Write the method createStars
            -   repeatedly call the method createStar and add the new star to the
                array of stars in the config object.  The number of stars is in the
                length property of the config object.
            -   bind the class to the method in the constructor
            -   call the method in the constructor
    */

    createStars() {
        for (let i = 0; i < this.config.length; i++) {
            this.config.stars[i] = this.createStar(i);
        }
    }

    /*
        -   Write the method drawStar.  Pass in a star as a parameter
            -   it should draw one star
            -   bind the class to the method
    */

    drawStar(star) {
        this.$context.fillStyle = star.color;
        this.$context.strokeStyle = star.color;
        this.$context.beginPath();
        this.$context.arc(star.position.x, star.position.y, star.radius, 0, 2 * Math.PI);
        this.$context.stroke();
        if ((star.velocity.x > .1 || star.velocity.x < -.1) &&
            (star.velocity.y > .1 || star.velocity.y < -.1))
            this.$context.fill();
        this.$context.closePath();
    }

    /*
        -   Write the method drawStars.  It should
            -   clear the canvas
            -   repeatedly call the method drawStar
            -   bind the class to the method
            -   call the method in the constructor
    */

    drawStars() {
        this.$context.clearRect(0, 0, this.$canvas.width, this.$canvas.height);
        for (let i = 0; i < this.config.length; i++) {
            this.drawStar(this.config.stars[i]);
        }
    }
    
    // END OF PART 1 - TEST AND DEBUG YOUR CODE - YOU SHOULD SEE STARS ON THE PAGE

    /*
        - PART 2 - Animate the stars - you can do this with setInterval or an animation frame
            -   Write the method moveStar.  It should take a star as it's parameter and
                move the star based on it's x and y position as well as it's x and y velocities.
                When the star bumps into the edge of the canvas, it should reappear on the canvas
                in a reasonable place but don't worry too much about the physics!
    */

    moveStar(star) {
        star.position.x += star.velocity.x;
        star.position.y += star.velocity.y;

        let absVelX = Math.abs(star.velocity.x);
        let absVelY = Math.abs(star.velocity.y);

        if (absVelX < .1 || absVelY < .1 ) {
            if (star.radius <= star.maxRadius && star.color != "rgb(255, 69, 0)") {
                star.color = "rgb(255, 69, 0)";
                star.lines = false;
            }
            else if (star.radius <= star.maxRadius + 3) {
                let a = (1 - (star.radius - star.maxRadius) / 3);
                star.color = "rgba(255, 69, 0, " + a + ")";
            }
            else {
                star.color = this.colorStar();
                star.radius = this.starSize();
                star.maxRadius = this.explosionSize(star.radius);
                star.velocity = this.setVelocity();
                star.position = this.starStart();
                star.lines = true;
            }
            star.radius += .05;
        } else {
            if ((star.position.x - star.radius) < 0 || (star.position.x + star.radius) > this.config.width) {
                star.velocity.x *= -.5;
                star.position.x += star.velocity.x * 2;
            }
            if ((star.position.y + star.radius) > this.config.height) {
                star.velocity.y *= -.5;
                star.y += star.velocity.y * 2;
            }
            else if ((star.position.y - star.radius) < 0) {
                star.velocity.y *= -1;
                star.y += star.velocity.y * 2;
            } else {
                star.velocity.x -= .0001;
                star.velocity.y -= .0001;
            }
        }
    }

    /*
            -   Write the method moveStars.  It should repeatedly call moveStar
    */
    moveStars() {
        for (let i = 0; i < this.config.length; i++) {
            this.moveStar(this.config.stars[i]);
        }
    }
    /*
            -   Write the method animateStars.  It should 
                -   clear the canvas
                -   move the stars
                -   draw the stars
            -   Setup the animation in the constructor.  It should call animateStars every 1/60th 
                of a second.
            -   NOTICE THAT I CREATE A NEW OBJECT WHEN YOU RESIZE THE PAGE.  YOU'LL WANT TO CANCEL
                THE ANIMATION WHERE I'VE WRITTEN THAT COMMENT.
    */
    animateStars() {
        this.moveStars();
        this.drawStars();
    }

    
    // END OF PART 2 - TEST AND DEBUG YOUR CODE - YOU SHOULD SEE STARS MOVE ON THE PAGE 

    /*
        - PART 3 - Add lines between stars that are "close" to eachother and are near the mouse
            -   I've given you 2 methods highlight and drawLines that you can use.  Or you can write your own
            -   Write the method drawLines
            -   Call it in an appropriate place
            -   Write the method highlight
            -   Add a mousemove event handler to the canvas that references highlight.  drawLines
                takes the position of the mouse into account.
      END OF PART 3 - TEST AND DEBUG YOUR CODE - YOU SHOULD SEE CONSTELLATIONS ON YOUR PAGE       
    */

    highlight(e) {
        this.config.position.x = e.pageX - this.$canvas.offsetLeft;
        this.config.position.y = e.pageY - this.$canvas.offsetTop;
    }
    drawLines () {
        for (let i = 0; i < this.config.length; i++) {
            for (let j = 0; j < this.config.length; j++) {
                let iStar = this.config.stars[i];
                let jStar = this.config.stars[j];
                if (iStar.lines && jStar.lines) {
                    if ((iStar.position.x - jStar.position.x) < this.config.distance &&
                        (iStar.position.y - jStar.position.y) < this.config.distance &&
                        (iStar.position.x - jStar.position.x) > - this.config.distance &&
                        (iStar.position.y - jStar.position.y) > - this.config.distance) {
                        if ((iStar.position.x - this.config.position.x) < this.config.radius &&
                            (iStar.position.y - this.config.position.y) < this.config.radius &&
                            (iStar.position.x - this.config.position.x) > - this.config.radius &&
                            (iStar.position.y - this.config.position.y) > - this.config.radius) {
                            if (iStar.color == jStar.color) {
                                this.$context.strokeStyle = iStar.color;
                            }
                            else {
                                this.$context.strokeStyle = this.config.line.color;
                            }
                            this.$context.beginPath();
                            this.$context.moveTo(iStar.position.x, iStar.position.y);
                            this.$context.lineTo(jStar.position.x, jStar.position.y);
                            this.$context.stroke();
                            this.$context.closePath();
                        }
                    }
                }
            }
        }
    }
}

let midnightsky;
window.addEventListener('load', () => midnightsky = new MidnightSky());

